"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerChatHandlers = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const chatModel_1 = require("../models/chatModel");
const userModels_1 = require("../models/userModels");
const messageModel_1 = require("../models/messageModel");
const mongoose_1 = require("mongoose");
// Store active user connections
const users = new Map(); // userId -> socketId
// Rate limiting for messages (userId -> timestamp)
const messageTimestamps = new Map();
const MESSAGE_TIMEOUT = 500; // 500ms between messages
const registerChatHandlers = (io) => {
    if (!process.env.JWT_SECRET) {
        throw new Error("JWT_SECRET is not defined in environment variables");
    }
    // Authentication middleware
    // Note: generateToken currently signs { id } (see config/generateToken.ts).
    // We decode the token to get the id and then fetch the full user from DB
    // so socket.user matches the shape used across the app (has _id, username, email, etc.).
    io.use((socket, next) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            const token = (_a = socket.handshake.auth) === null || _a === void 0 ? void 0 : _a.token;
            if (!token) {
                return next(new Error("Authentication token missing"));
            }
            // token payload is { id } as generated by generateToken.ts
            const decoded = jsonwebtoken_1.default.verify(token, process.env.JWT_SECRET);
            // Fetch user from DB once per connection. This keeps the socket user up-to-date
            // and avoids relying on token to carry user fields.
            const userDoc = yield userModels_1.User.findById(decoded.id).select("-password");
            if (!userDoc)
                return next(new Error("User not found"));
            socket.user = {
                _id: userDoc._id.toString(),
                username: userDoc.username,
                email: userDoc.email,
                pic: userDoc.pic,
            };
            next();
        }
        catch (err) {
            console.error("Socket auth error:", err);
            next(new Error("Invalid token"));
        }
    }));
    io.on("connection", (socket) => {
        const authenticatedSocket = socket;
        const user = authenticatedSocket.user;
        console.log(`‚úÖ User connected: ${user.username} (${socket.id})`);
        users.set(user._id, socket.id);
        socket.emit("connected", { userId: user._id });
        // ====== JOIN CHAT ======
        socket.on("join chat", (chatId) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                if (!chatId || !mongoose_1.Types.ObjectId.isValid(chatId)) {
                    return socket.emit("error", "Invalid chat ID");
                }
                // Verify user is member of the chat
                const chat = yield chatModel_1.Chat.findOne({
                    _id: chatId,
                    users: user._id,
                });
                if (!chat) {
                    return socket.emit("error", "Not authorized to join this chat");
                }
                socket.join(chatId);
                yield userModels_1.User.findByIdAndUpdate(user._id, { selectedChat: chatId });
                console.log(`üì• ${user.username} joined chat ${chatId}`);
            }
            catch (err) {
                console.error("Join chat error:", err);
                socket.emit("error", "Failed to join chat");
            }
        }));
        // ====== LEAVE CHAT ======
        socket.on("leave chat", () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const userDoc = yield userModels_1.User.findById(user._id);
                if (userDoc === null || userDoc === void 0 ? void 0 : userDoc.selectedChat) {
                    socket.leave(userDoc.selectedChat.toString());
                }
                yield userModels_1.User.findByIdAndUpdate(user._id, { selectedChat: null });
                console.log(`üì§ ${user.username} left chat`);
            }
            catch (err) {
                console.error("Leave chat error:", err);
            }
        }));
        // ====== SEND MESSAGE ======
        socket.on("send message", (data) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const { content, chatId } = data;
                if (!content || !chatId) {
                    return socket.emit("error", "Missing message content or chatId");
                }
                // Rate limiting check
                const lastMessageTime = messageTimestamps.get(user._id) || 0;
                const now = Date.now();
                if (now - lastMessageTime < MESSAGE_TIMEOUT) {
                    return socket.emit("error", "Please wait before sending another message");
                }
                messageTimestamps.set(user._id, now);
                // Verify user is member of the chat
                const chat = yield chatModel_1.Chat.findOne({
                    _id: chatId,
                    users: user._id,
                });
                if (!chat) {
                    return socket.emit("error", "Not authorized to send messages to this chat");
                }
                const newMessage = {
                    sender: user._id,
                    content,
                    chat: chatId,
                    delivered: true,
                };
                let message = yield messageModel_1.Message.create(newMessage);
                message = yield message.populate("sender", "username pic email");
                message = yield message.populate("chat");
                yield userModels_1.User.populate(message.chat, {
                    path: "users",
                    select: "username pic email selectedChat unreadMessages",
                });
                yield chatModel_1.Chat.findByIdAndUpdate(chatId, { latestMessage: message });
                const chatUsers = chat.users || [];
                // Mark unread for users not in this chat
                yield userModels_1.User.updateMany({
                    _id: { $in: chatUsers },
                    selectedChat: { $ne: chatId },
                }, { $push: { unreadMessages: message } }, { new: true });
                // Emit message to others in room
                socket.to(chatId).emit("received message", message);
                socket.emit("message sent", message);
            }
            catch (err) {
                console.error("Socket message error:", err);
                socket.emit("error", "Error sending message");
            }
        }));
        // ====== TYPING EVENTS ======
        socket.on("typing", (chatId) => {
            if (mongoose_1.Types.ObjectId.isValid(chatId)) {
                socket.to(chatId).emit("typing", { chatId, userId: user._id });
            }
        });
        socket.on("stop typing", (chatId) => {
            if (mongoose_1.Types.ObjectId.isValid(chatId)) {
                socket.to(chatId).emit("stop typing", { chatId, userId: user._id });
            }
        });
        // ====== DISCONNECT ======
        socket.on("disconnect", () => __awaiter(void 0, void 0, void 0, function* () {
            users.delete(user._id);
            yield userModels_1.User.findByIdAndUpdate(user._id, { selectedChat: null });
            messageTimestamps.delete(user._id); // Clean up rate limiting data
            console.log(`‚ùå ${user.username} disconnected`);
        }));
    });
};
exports.registerChatHandlers = registerChatHandlers;
