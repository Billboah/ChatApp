import { Server, Socket } from "socket.io";
import jwt from "jsonwebtoken";
import { Chat } from "../models/chatModel";
import { User } from "../models/userModels";
import { Message } from "../models/messageModel";
import { Types } from "mongoose";

// Extended Socket interface with user property
interface AuthenticatedSocket extends Socket {
  user: AuthPayload;
}

interface AuthPayload {
  _id: string;
  username: string;
  email: string;
  pic?: string;
}

// Store active user connections
const users = new Map<string, string>(); // userId -> socketId

// Rate limiting for messages (userId -> timestamp)
const messageTimestamps = new Map<string, number>();
const MESSAGE_TIMEOUT = 500; // 500ms between messages

export const registerChatHandlers = (io: Server) => {
  if (!process.env.JWT_SECRET) {
    throw new Error("JWT_SECRET is not defined in environment variables");
  }

  // Authentication middleware
  // Note: generateToken currently signs { id } (see config/generateToken.ts).
  // We decode the token to get the id and then fetch the full user from DB
  // so socket.user matches the shape used across the app (has _id, username, email, etc.).
  io.use(async (socket: Socket, next) => {
    try {
      const token = socket.handshake.auth?.token;
      if (!token) {
        return next(new Error("Authentication token missing"));
      }

      // token payload is { id } as generated by generateToken.ts
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
        id: string;
      };

      // Fetch user from DB once per connection. This keeps the socket user up-to-date
      // and avoids relying on token to carry user fields.
      const userDoc = await User.findById(decoded.id).select("-password");
      if (!userDoc) return next(new Error("User not found"));

      (socket as AuthenticatedSocket).user = {
        _id: userDoc._id.toString(),
        username: (userDoc as any).username,
        email: (userDoc as any).email,
        pic: (userDoc as any).pic,
      };

      next();
    } catch (err) {
      console.error("Socket auth error:", err);
      next(new Error("Invalid token"));
    }
  });

  io.on("connection", (socket: Socket) => {
    const authenticatedSocket = socket as AuthenticatedSocket;
    const user = authenticatedSocket.user;

    console.log(`‚úÖ User connected: ${user.username} (${socket.id})`);

    users.set(user._id, socket.id);
    socket.emit("connected", { userId: user._id });

    // ====== JOIN CHAT ======
    socket.on("join chat", async (chatId: string) => {
      try {
        if (!chatId || !Types.ObjectId.isValid(chatId)) {
          return socket.emit("error", "Invalid chat ID");
        }

        // Verify user is member of the chat
        const chat = await Chat.findOne({
          _id: chatId,
          users: user._id,
        });

        if (!chat) {
          return socket.emit("error", "Not authorized to join this chat");
        }

        socket.join(chatId);
        await User.findByIdAndUpdate(user._id, { selectedChat: chatId });
        console.log(`üì• ${user.username} joined chat ${chatId}`);
      } catch (err) {
        console.error("Join chat error:", err);
        socket.emit("error", "Failed to join chat");
      }
    });

    // ====== LEAVE CHAT ======
    socket.on("leave chat", async () => {
      try {
        const userDoc = await User.findById(user._id);
        if (userDoc?.selectedChat) {
          socket.leave(userDoc.selectedChat.toString());
        }
        await User.findByIdAndUpdate(user._id, { selectedChat: null });
        console.log(`üì§ ${user.username} left chat`);
      } catch (err) {
        console.error("Leave chat error:", err);
      }
    });

    // ====== SEND MESSAGE ======
    socket.on("send message", async (data) => {
      try {
        const { content, chatId } = data;
        if (!content || !chatId) {
          return socket.emit("error", "Missing message content or chatId");
        }

        // Rate limiting check
        const lastMessageTime = messageTimestamps.get(user._id) || 0;
        const now = Date.now();
        if (now - lastMessageTime < MESSAGE_TIMEOUT) {
          return socket.emit(
            "error",
            "Please wait before sending another message"
          );
        }
        messageTimestamps.set(user._id, now);

        // Verify user is member of the chat
        const chat = await Chat.findOne({
          _id: chatId,
          users: user._id,
        });

        if (!chat) {
          return socket.emit(
            "error",
            "Not authorized to send messages to this chat"
          );
        }

        const newMessage = {
          sender: user._id,
          content,
          chat: chatId,
          delivered: true,
        };

        let message = await Message.create(newMessage);
        message = await message.populate("sender", "username pic email");
        message = await message.populate("chat");
        await User.populate(message.chat, {
          path: "users",
          select: "username pic email selectedChat unreadMessages",
        });

        await Chat.findByIdAndUpdate(chatId, { latestMessage: message });

        const chatUsers = chat.users || [];

        // Mark unread for users not in this chat
        await User.updateMany(
          {
            _id: { $in: chatUsers },
            selectedChat: { $ne: chatId },
          },
          { $push: { unreadMessages: message } },
          { new: true }
        );

        // Emit message to others in room
        socket.to(chatId).emit("received message", message);
        socket.emit("message sent", message);
      } catch (err) {
        console.error("Socket message error:", err);
        socket.emit("error", "Error sending message");
      }
    });

    // ====== TYPING EVENTS ======
    socket.on("typing", (chatId: string) => {
      if (Types.ObjectId.isValid(chatId)) {
        socket.to(chatId).emit("typing", { chatId, userId: user._id });
      }
    });

    socket.on("stop typing", (chatId: string) => {
      if (Types.ObjectId.isValid(chatId)) {
        socket.to(chatId).emit("stop typing", { chatId, userId: user._id });
      }
    });

    // ====== DISCONNECT ======
    socket.on("disconnect", async () => {
      users.delete(user._id);
      await User.findByIdAndUpdate(user._id, { selectedChat: null });
      messageTimestamps.delete(user._id); // Clean up rate limiting data
      console.log(`‚ùå ${user.username} disconnected`);
    });
  });
};
