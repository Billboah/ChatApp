import { Server, Socket } from "socket.io";
import jwt from "jsonwebtoken";
import { Chat } from "../models/chatModel";
import { User } from "../models/userModels";
import { Message } from "../models/messageModel";
import { Types } from "mongoose";

// Extended Socket interface with user property
interface AuthenticatedSocket extends Socket {
  user: AuthPayload;
}

interface AuthPayload {
  _id: string;
  username: string;
  email: string;
  pic?: string;
}

// Store active user connections
const connectedUsers = new Map<string, string>(); // userId -> socketId

// Rate limiting for messages (userId -> timestamp)
const messageTimestamps = new Map<string, number>();
const MESSAGE_TIMEOUT = 500; // 500ms between messages

export const registerChatHandlers = (io: Server) => {
  if (!process.env.JWT_SECRET) {
    throw new Error("JWT_SECRET is not defined in environment variables");
  }

  // Authentication middleware
  // Note: generateToken currently signs { id } (see config/generateToken.ts).
  // We decode the token to get the id and then fetch the full user from DB
  // so socket.user matches the shape used across the app (has _id, username, email, etc.).
  io.use(async (socket: Socket, next) => {
    try {
      const token = socket.handshake.auth?.token;
      if (!token) {
        return next(new Error("Authentication token missing"));
      }

      // token payload is { id } as generated by generateToken.ts
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
        id: string;
      };

      // Fetch user from DB once per connection. This keeps the socket user up-to-date
      // and avoids relying on token to carry user fields.
      const userDoc = await User.findById(decoded.id).select("-password");
      if (!userDoc) return next(new Error("User not found"));

      (socket as AuthenticatedSocket).user = {
        _id: userDoc._id.toString(),
        username: userDoc.username,
        email: userDoc.email,
        pic: userDoc.pic,
      };

      next();
    } catch (err) {
      console.error("Socket auth error:", err);
      next(new Error("Invalid token"));
    }
  });

  io.on("connection", (socket: Socket) => {
    const authenticatedSocket = socket as AuthenticatedSocket;
    const user = authenticatedSocket.user;

    console.log(`‚úÖ User connected: ${user.username} (${socket.id})`);

    connectedUsers.set(user._id, socket.id);
    socket.emit("connected", { userId: user._id });

    // ====== JOIN CHAT ======
    // Handle individual chat selection/creation
    socket.on("access chat", async (userId: string) => {
      try {
        if (!userId || !Types.ObjectId.isValid(userId)) {
          return socket.emit("error", "Invalid user ID");
        }

        // Find existing chat between users or create new one
        let chat = await Chat.findOne({
          isGroupChat: false,
          users: { $all: [user._id, userId] },
        }).populate("users", "-password");

        if (chat) {
          // Existing chat found
          socket.emit("chat accessed", chat);
          socket.join(chat._id.toString());
          await User.findByIdAndUpdate(user._id, { selectedChat: chat._id });
        } else {
          // Create new chat
          chat = await Chat.create({
            chatName: "sender",
            isGroupChat: false,
            users: [user._id, userId],
          });

          const fullChat = await Chat.findById(chat._id).populate(
            "users",
            "-password"
          );

          // Notify both users
          const recipientSocketId = connectedUsers.get(userId);
          if (recipientSocketId) {
            io.to(recipientSocketId).emit("new chat", fullChat);
          }
          socket.emit("chat accessed", fullChat);
          socket.join(fullChat!._id.toString());
          await User.findByIdAndUpdate(user._id, {
            selectedChat: fullChat!._id,
          });
        }
      } catch (err) {
        console.error("Access chat error:", err);
        socket.emit("error", "Failed to access chat");
      }
    });

    socket.on("join chat", async (chatId: string) => {
      try {
        if (!chatId || !Types.ObjectId.isValid(chatId)) {
          return socket.emit("error", "Invalid chat ID");
        }

        // Verify user is member of the chat
        const chat = await Chat.findOne({
          _id: chatId,
          users: user._id,
        });

        if (!chat) {
          return socket.emit("error", "Not authorized to join this chat");
        }

        socket.join(chatId);
        await User.findByIdAndUpdate(user._id, { selectedChat: chatId });
        console.log(`üì• ${user.username} joined chat ${chatId}`);
      } catch (err) {
        console.error("Join chat error:", err);
        socket.emit("error", "Failed to join chat");
      }
    });

    // ====== LEAVE CHAT ======
    socket.on("leave chat", async () => {
      try {
        const userDoc = await User.findById(user._id);
        if (userDoc?.selectedChat) {
          socket.leave(userDoc.selectedChat.toString());
        }
        await User.findByIdAndUpdate(user._id, { selectedChat: null });
        console.log(`üì§ ${user.username} left chat`);
      } catch (err) {
        console.error("Leave chat error:", err);
      }
    });

    // ====== CREATE CHAT (group or personal) ======
    socket.on("create chat", async (data) => {
      try {
        // data: { type: "group"|"personal", users: [userIds], name?: string, pic?: string }
        const { type, users, name, pic } = data;
        const creatorId = user._id;
        if (!type || !Array.isArray(users) || users.length === 0) {
          return socket.emit("error", "Invalid chat creation payload");
        }

        if (type === "personal") {
          if (users.length !== 2) {
            return socket.emit(
              "error",
              "Personal chat must have exactly two users"
            );
          }
          // Check if chat exists
          const isChat = await Chat.find({
            isGroupChat: false,
            users: { $all: users },
          });
          if (isChat.length > 0) {
            // Populate and emit existing chat
            const fullChat = await Chat.findOne({ _id: isChat[0]._id })
              .populate("users", "username pic email")
              .populate("groupAdmin", "username pic email")
              .populate({
                path: "latestMessage",
                select: "chat content delivered sender",
                populate: { path: "sender", select: "username pic email" },
              })
              .sort({ updatedAt: -1 });
            if (fullChat) {
              users.forEach((uid: string) => {
                const sid = connectedUsers.get(uid);
                if (sid) io.to(sid).emit("chat created", fullChat.toObject());
              });
              socket.emit("chat created", fullChat.toObject());
              return;
            }
          }
          // Create new chat
          const chatData = {
            chatName: "sender",
            isGroupChat: false,
            users,
          };
          const createdChat = await Chat.create(chatData);
          const fullChat = await Chat.findOne({ _id: createdChat._id })
            .populate("users", "username pic email")
            .populate("groupAdmin", "username pic email")
            .populate({
              path: "latestMessage",
              select: "chat content delivered sender",
              populate: { path: "sender", select: "username pic email" },
            })
            .sort({ updatedAt: -1 });
          if (fullChat) {
            users.forEach((uid: string) => {
              const sid = connectedUsers.get(uid);
              if (sid) io.to(sid).emit("chat created", fullChat.toObject());
            });
            socket.emit("chat created", fullChat.toObject());
          }
        } else if (type === "group") {
          if (!name || typeof name !== "string") {
            return socket.emit("error", "Group chat must have a name");
          }
          let groupUsers = [...users];
          if (!groupUsers.includes(creatorId)) groupUsers.push(creatorId);
          if (groupUsers.length < 3) {
            return socket.emit(
              "error",
              "More than 2 users are required to form a group chat"
            );
          }
          const groupChat = await Chat.create({
            chatName: name,
            pic,
            users: groupUsers,
            groupAdmin: creatorId,
            isGroupChat: true,
          });
          const fullGroupChat = await Chat.findOne({ _id: groupChat._id })
            .populate("users", "username pic email")
            .populate("groupAdmin", "username pic email")
            .populate({
              path: "latestMessage",
              select: "chat content delivered sender",
              populate: { path: "sender", select: "username pic email" },
            })
            .sort({ updatedAt: -1 });
          if (fullGroupChat) {
            groupUsers.forEach((uid: string) => {
              const sid = connectedUsers.get(uid);
              if (sid)
                io.to(sid).emit("chat created", fullGroupChat.toObject());
            });
            socket.emit("chat created", fullGroupChat.toObject());
          }
        } else {
          socket.emit("error", "Unknown chat type");
        }
      } catch (err) {
        console.error("Create chat error:", err);
        socket.emit("error", "Failed to create chat");
      }
    });

    // ====== SEND MESSAGE ======
    socket.on("send message", async (data) => {
      try {
        const { content, chatId, tempId } = data;
        if (!content || !chatId) {
          return socket.emit("error", "Missing message content or chatId");
        }

        // Rate limiting check
        const lastMessageTime = messageTimestamps.get(user._id) || 0;
        const now = Date.now();
        if (now - lastMessageTime < MESSAGE_TIMEOUT) {
          return socket.emit(
            "error",
            "Please wait before sending another message"
          );
        }
        messageTimestamps.set(user._id, now);

        // Verify user is member of the chat
        const chat = await Chat.findOne({
          _id: chatId,
          users: user._id,
        });

        if (!chat) {
          return socket.emit(
            "error",
            "Not authorized to send messages to this chat"
          );
        }

        // Create and populate message
        const newMessage = await Message.create({
          sender: user._id,
          content,
          chat: chatId,
          delivered: true,
        });

        let message = await newMessage.populate("sender", "username pic email");
        message = await message.populate("chat");
        await User.populate(message.chat, {
          path: "users",
          select: "username pic email selectedChat unreadMessages",
        });

        await Chat.findByIdAndUpdate(chatId, { latestMessage: message });

        const chatUsers = chat.users || [];

        // Mark unread for users not in this chat
        await User.updateMany(
          { _id: { $in: chatUsers }, selectedChat: { $ne: chatId } },
          { $push: { unreadMessages: message } },
          { new: true }
        );

        // Emit to others in the room (those who have joined)
        socket
          .to(chatId)
          .emit("received message", { ...message.toObject(), tempId });

        // Also send the message directly to connected users who are NOT joined
        // to the chat room (so users receive updates even when they haven't
        // selected/opened the chat). This avoids missing updates for users
        // that are online but haven't joined the chat socket room.
        const messageObj = message.toObject();
        for (const uid of chatUsers) {
          const userIdStr = uid.toString();
          if (userIdStr === user._id) continue; // skip sender

          const sid = connectedUsers.get(userIdStr);
          if (!sid) continue;

          try {
            const clientSocket = io.sockets.sockets.get(sid);
            const isInRoom = clientSocket
              ? clientSocket.rooms.has(chatId)
              : false;
            if (!isInRoom) {
              io.to(sid).emit("received message", { ...messageObj, tempId });
            }
          } catch (err) {
            // If socket lookup fails, fall back to emitting by socket id
            io.to(sid).emit("received message", { ...messageObj, tempId });
          }
        }

        // ‚úÖ Send confirmation to sender ‚Äî send a plain JS object (not a Mongoose document)
        socket.emit("message sent", { tempId, message: message.toObject() });
      } catch (err) {
        console.error("Socket message error:", err);
        socket.emit("error", "Error sending message");
      }
    });

    // ====== TYPING EVENTS ======
    socket.on("typing", (chatId: string) => {
      if (Types.ObjectId.isValid(chatId)) {
        socket.to(chatId).emit("typing", { chatId, userId: user._id });
      }
    });

    socket.on("stop typing", (chatId: string) => {
      if (Types.ObjectId.isValid(chatId)) {
        socket.to(chatId).emit("stop typing", { chatId, userId: user._id });
      }
    });

    // ====== DISCONNECT ======
    socket.on("disconnect", async () => {
      connectedUsers.delete(user._id);
      await User.findByIdAndUpdate(user._id, { selectedChat: null });
      messageTimestamps.delete(user._id); // Clean up rate limiting data
      console.log(`‚ùå ${user.username} disconnected`);
    });
  });
};
